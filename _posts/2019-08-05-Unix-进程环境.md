---
layout: post
author: eature
published: true
categories: 系统编程
tags:
- c
- 进程
- unix
- Linux
---

##### 进程的终止
正常终止
1. 从`main`函数中返回
2. 调用exit
2. 调用`_exit`或者`_Exit`
3. 最后一个线程从启动返回
4. 从最后一个线程中pthread_exit
  
异常终止
1. 调用abort
2. 接到一个终止信号
3. 最后一个线程对取消信号做出响应

* ###### 退出函数
退出函数用于正常终止一个程序， `_exit`和`_Exit`立即进入内核终端程序， `exit`则先执行一些清理处理再进入内核  
```
    #include <stdlib.h>
    void exit(int status);
    void _Exit(int status);
    
    #include <unistd.h>
    void _exit(int status);
```

3个函数都带有一个整型参数， 称为终止状态  
在main函数中返回一个整型值与调用exit返回是等价的
> echo $? //打印终止符

每个进程都有一个唯一的非负整数标识这个进程， 称为进程id， id为0的进程是调度进程， 被称为交换进程。进程为1的进程是init进程。  
除了进程id， 每个进程还有其他的一些描述符， 可以通过下列函数获取  
```
    #include <ybustd.h>
    pid_t getpid(void)  //返回进程id
    pid_t getppid(void) //返回父进程id
    uid_t getuid(void)  //返回调用进程的实际用户id
    uid_t geteuid(void) //返回调用进程的有效用户id
    gid_t getgid(void)  //返回进程的实际组id
    gid_t getegid(void) //返回进程的有效组id
```

一个现有的进程通过`fork`派生出一个新的进程  
```
    #include <unistd.h>
    pid_t fork(void); //错误返回-1， 父进程返回子进程id， 子进程返回0 
```

fork子进程后， 子进程是父进程的副本， 父子进程共享正文段， fork进程进程跟着exec， 所以很多副本的实现使用了写时复制（copy on write）, 父进程的数据段、栈、堆由父子进程共享， 并且内核将其设置为只读， 如果父子进程中任意进程需要修改这些数据， 再将需要修改的数据copy一份出来  

在fork之后， 父子进程的执行顺序时不确定的， 取决于内核的调度算法  

子进程在终止后， 父进程未对其信息进行回收的话， 这个进程就会编程僵死进程， 父进程可以通过`wait`或者`waitpid`来获取子进程的终止信息， 当一个进程正常或者异常终止的时候， 内核会发送一个SIGCHLD信号给其父进程， 父进程可以选择忽略这个信号， 或者提供一个该信号捕捉到时需要执行的一个函数， 对于这种信号， 系统默认的行为是忽略他  

```
    #include <sys/wait.h>
    
    pid_t wait(int *statloc);
    pid_t waitpid(pid_t pid, int *statloc, int options);
```
成功则返回进程id， 出错则返回0或者-1  

如果子进程还没有终止， 则wait函数会阻塞， waitpid可以使用相应的参数使其不阻塞， 如果子进程已经终止， 并且是一个僵死进程， wait则立即返回并取得该子进程的状态， 如果有多个子进程， 则在某一个子进程终止时立刻返回  

`waitid`是另一个可以取得进程终止状态的函数， 与waitpid类似， 并且提供了更多的灵活性  
```
    #include <sys/weait.h>
    int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
```









