---
layout: post
author: eature
published: true
categories: MySQL
modify: 2019-06-11
tags:
- mysql
---

在平常的MySQL操作中， 除了基本的CURD外， 接触最多的应该就是事务和索引了  
接下来， 依次对事务以及索引的知识点进行归纳总结  

#### 事务

在平常的使用中， 用到事务最多的就是事务的原子性， 即多条语句的的执行， 要么都成功， 要么都失败， 我们知道， 事务的四个特性是ACID， 即  
1. 原子性 Atomicity
2. 一致性 Consistency
3. 隔离性 Isolation
4. 持久性 Durability

##### 原子性
原子性就是， 在事务中的操作， 要么全部完成， 中途有操作失败， 则回滚到事务开始时的状态， 在事务开始的时候，MySQL会记录undo log，undo log记录的是修改前数据的值， 在事务中途， 如果数据库挂逼了， 或者执行了回滚操作， 就根据记录的undo log来将数据恢复成原来的样子， 在事务提交后， undo log不会马上被删除， 而是放在待删除队列中， 在不需要比当前undo log更早的数据的时候， undo log就会被删除。
##### 一致性
一致性是指事务使得系统从一个一致的状态转换到另一个一致状态，对于这句话的理解是， 假设数据为10， 当数据减1得到另外一个数据， 那么这个数据一定是9， 即数据库数据的两个状态一个是逻辑上成立的， 事务可以不同程度的一致性：  
##### 隔离性
隔离性指的是两个不同事务之前相互隔离， 互不影响， 隔离级别越严实， 效率就会越低， 隔离级别包括以下  
1. 读未提交， 一个事务还没提交的情况下， 他的更改就可以被其他事务看到
2. 读提交， 一个数据提交以后， 他的修改才能被其他事务看到
3. 可重复读， 一个事务在执行过成中看到的数据总是一样的， 在可重复读隔离级别下， 未提交的事务不会被其他事务看到
4. 串行化， 就是写会加写锁， 读会加读锁， 当读写冲突的时候， 后访问的事务需要等前一个事务执行完成才可以继续执行


* 事务的隔离是怎么做的  
我们知道， 在事务中， 隔离得越严实， 所需要得额外消耗就越高  
在MySQL， 每条记录都会有多个版本， 当数据库需要更新一条数据得时候， 不是直接将数据更新， 而是将当前版本得数据设未老版本， 并创建一个新版本得数据， 这就是数据库得多版本并发控制  
在InnoDB里面， 每个事务都有一个唯一的事务id， 叫做transaction_id, 在事务开始的时候向事务系统申请， 是按申请的顺序严格递增的，在事务更新数据的时候， 都会生成一个新的数据版本， 并将transaction_id赋值给这条记录， 记未row_trx_id, 数据库数据的多版本并不是真是的存在的， 而是通过row_trx_id和undo log计算出来的，
在可重复读隔离级别下， 当事务开启的时候， 事务会创建一个视图， 之后在事务的执行期间， 其他事务的修改就不会影响当前的事务， 实际上， 在可重复读隔离级别下， 当数据库访问一条数据的时候， 会用当前的transaction_id与访问数据的row_trx_id比较， 如果row_trx_id大于当前事务的transaction_id的话， 则这个版本的数据对当前事务是不可见的， 应该依次往回找， 配合undo log来获取可读的老版本的数据。 这样执行下来， 一个事务无论在什么时候查询， 看到的数据总是一致的， 称为一致性读。  
基于这种实现方式， 假设有记录（1， 100）， 在事务A先更新记录为（1， 104）， 事务B在执行类似`set b=b+1`的执行语句， 此时记录的值会设置为（1， 105）， 因为此时记录的最新版本是事务A， 所以更新需要基于事务A的版本来进行。因此更新后的数据是105， 此时数据就跟意向中的不一致了， 所以， 在事务对数据表进行更新操作的时候， 会对数据加写锁， 直到事务提交或者回滚则释放锁， 如果在未提交事务的时候其他事务对这行数据进行更新操作， 则会进入锁等待环节， 直到获取到锁或者等待超时。因此， 在实际中， 应该尽量避免长事务， 长事务会导致大量的更新操作进入锁等待， 会导致请求时间边长甚至拖垮整个服务。  
读未提交就是当前读， 即事务的更改能被其他事务立马知道， 读提交的隔离级别下， 用select语句加上`for update` 或者 `lock in share mode`即可实现，

##### 持久性
持久性就是事务提交后，对系统的影响是永久的， 持久性是有InnoDB的`redo log`来维护的， 在MySQL中， 每条更新操作都会写一条`redo log`， redo log记录的是物理操作， 记录的是对每个数据页的修改， 所有的更新操作都会先写到redo log中， 然后在将redo log中的数据更新到磁盘中， 因此， 即使数据库异常重启或者宕机， 所有的操作还是记录才redo log中， 当数据库实例启动以后， 可以读取redo log中的数据操作， 将宕机前为写入到数据文件的数据再一次写入， 因此数据不会丢失， 保证了数据的持久性  


#### 索引
索引的数据结构模型常用的有
1. 有序数组
2. hash
3. B+树
有序数组是指用一块连续的内存并将数据按一定的顺序存储，有序数组最大的优势在于随机访问的时间复杂度是O(1)， 但是对于插入操作， 有序数组需要挪动插入位置以后的所有数据来完成插入操作  
hash存储是来hash表来组织索引数据， hash表存储数据的优势是等值查询和插入更新的时间复杂度， 缺点就是对于范围查询， 需要遍历全部数据  
B+树，是在查找与插入操作下均衡的实现方式，

大部分情况下， 我们使用的索引都是B+树索引，在MySQL中，每个索引在InnoDb中对应一颗B+树， 根据节点数据的不同， 可以分为普通索引和主键索引  
在主键索引中， 叶子节点中存储的数据是整行数据，在普通索引中， 叶子节点存储的数据是主键id， 所以在InnoDb中， 非主键索引也称为二级索引，为什么要这么做呢， 我想到的结果大概是， 如果在每个索引的叶子节点中都存储整行数据， 那么存储空间的消耗会变得大的多， 使用这种方案应该是兼顾查找性能和存储得折中方案
* 使用了索引和未使用索引在数据查询中有什么区别
我们知道， 索引是有序的， 在进性数据查找时， 如果使用了索引， 那么只需要找到第一个满足条件的数据并往下遍历， 直到不满足条件， 则循环退出， 将结果集返回给客户端， 但如果未使用索引， 则需要进行全表扫描，因为数据时无序的， 所以， 需要从第一行数据开始， 遍历整张表， 取出满足条件的数据作为结果集返回给客户端， 数据量大的情况下， 全表扫描对性能的影响很大， 甚至拖垮整个数据库， 所以， 在使用中， 要尽量使用索引查询， 避免全表扫描

* 普通索引与主键索引在数据查询中的区别  
使用主键索引查找数据时， 因为在主键索引树中叶子节点所存储的数据是整行数据， 所以， 使用护肩索引查找数据时， 找到对应的叶子节点就可以获取到整行数据， 查找次数是一次  
当使用普通索引进行数据搜索时， 对应的过程是这样的，现在对应的耳机索引树上找到对应的叶子节点， 拿到叶子节点中的主键id， 再拿主键id到主键索引树上查找数据， 所以， 使用二级索引进行数据查找时， 需要进行两次所有， 用主键id到主键索引树上查找数据的操作叫做回表  
因为使用主键索引查找数据比用普通索引查找要上一次回表操作， 索引， 在现实中， 应该尽量的使用主键索引进行数据查询  

* 唯一索引与普通索引的区别
唯一索引和普通索引都是二级索引， 不同的是唯一索引在数据库层面进行了数据的唯一性判断， 那么， 唯一索引与普通索引在使用上有什么差别呢  
在查询中， 如果使用的索引是唯一索引， 因为索引本身做了唯一性约束， 所以， 在等值查询的时候， 使用唯一索引查找的时候， 当找到满足条件的行后， 会直接退出， 将结果返回给客户端， 但是普通索引则还需要再往下遍历，直到找到不满足条件的行， 在整张表的数据是唯一的情况下， 普通索引要比唯一索引扫描一行数据， 实际对查找的性能影响不大  
在更新操作中， InnoDb在每个更新的时候会将更新操作先记录在`change buffer`中， 再统一同步到磁盘上， 由于change buffer是在内存中的， 所以更新数据会变得很快，但是， change buffer只能在普通索引上使用， 因为， 在更新唯一索引的时候， 由于需要做唯一性判断， 所以需要读取原表的数据， 这样的话，也就需要将磁盘中的数据读入到内存中， 既然数据已经在内存中了， 就没有必要再使用change buffer 了， 直接更新内存中的数据就行， 所以， 在进行更新操作的时候， 由于普通索引可以使用change buffer， 唯一所以需要读取磁盘中的数据， 有额外的磁盘消耗， 所以， 在更新操作的时候， 普通索引的性能是要由于唯一索引的。  
因为唯一索引在查找中的性能相对普通索引的优势可以忽略不记， 但是在更新操作的性能上却要明显的低于普通索引， 所以， 在实际中， 业务层能够保证数据的唯一性的情况下， 应该尽量使用普通索引

* 什么是覆盖索引
首先来说说联合索引， 根据字面意思就知道， 联合索引就是用几个列组成的索引叫联合索引  
那么覆盖索引与单独的普通索引是什么关系， 我们知道， 联合索引的使用规则是最左前缀， 也就是会用到最左边字段的索引， 举个栗子  
在用户的收入信息里面有这样一个索引```KEY `unique_idx_qbm` (`qid`,`book_id`,`month`)```, 那么在进行数据查询的时候， 如果where语句中有使用qid进行条件查询， 那么MySQL就会用到`unique_idx_qbm`这个索引进行数据查询， 如果没有用qid进行查询， 只用book_id或者month或者book_id和month的话， MySQL将不会使用到这个索引，而是走全表扫描的方式进行数据查询， 所以， 在实际情况中， 应该尽量的考虑索引的复用， 不建一些没有必要的索引， 比如， 通过联合索引如果调整顺序可以少维护一个索引  
在联合索引上又引申出另外一个概念就是覆盖索引， 覆盖索引的意思就是， 查询的结果字段已经在索引上有了， 即索引字段覆盖了查询字段， 因为覆盖索引上已经拥有了全部的数据字段， 所以在索引上查询数据的时候， 可以直接将结果集返回， 而省去了回表的操作， 能够提升数据库的查询性能  

* 前缀索引
给字符串加上索引有两种方式， 一种是直接以改字段作为索引， 第二种是以该字符串前面n个字节作为索引，也就是前缀索引， 前缀索引的优势就在于可以减少占用的空间， 而这样做的代价就是会相应的增加扫描行数， 因为只截取字符串的前面一段会降低字符串的区分度  
举个例子， 有个email字段， 假设有下面的一些数据  
> hello123@gmail.com  
> hello456@gmail.com  
> hello789@gmail.com  
> hello567@gmail.com    

假设有普通索引`A(email)`和前缀索引`B(email(5))`, 那么， 在进行数据查找的时候， 使用索引A则只要扫描一行数据， 而使用索引B的话则要扫描全表， 当然， 在现实当中， 我们可以使用相应的方式来增加字段的区分度来减少扫描行数， 我觉得实际应用中， 前缀索引的使用场景应该是对于字段长度特别长但是又经常需要用来进行数据查询的字段， 通过使用前缀索引用来减少索引的空间占用  
