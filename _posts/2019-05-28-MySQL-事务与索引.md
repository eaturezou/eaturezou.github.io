---
layout: post
author: eature
published: true
categories: MySQL
tags:
- mysql
---

在平常的MySQL操作中， 除了基本的CURD外， 接触最多的应该就是事务和索引了  
接下来， 依次对事务以及索引的知识点进行归纳总结  

#### 事务

在平常的使用中， 用到事务最多的就是事务的原子性， 即多条语句的的执行， 要么都成功， 要么都失败， 我们知道， 事务的四个特性是ACID， 即  
1. 原子性 Atomicity
2. 一致性 Consistency
3. 隔离性 Isolation
4. 持久性 Durability

##### 原子性
原子性就是， 在事务中的操作， 要么全部完成， 中途有操作失败， 则回滚到事务开始时的状态， 在事务开始的时候，MySQL会记录undo log，undo log记录的是修改前数据的值， 在事务中途， 如果数据库挂逼了， 或者执行了回滚操作， 就根据记录的undo log来将数据恢复成原来的样子， 在事务提交后， undo log不会马上被删除， 而是放在待删除队列中， 再判断是否需要删除。
##### 一致性
一致性是指事务使得系统从一个一致的状态转换到另一个一致状态，对于这句话的理解是， 假设数据为10， 当数据减1得到另外一个数据， 那么这个数据一定是9， 即数据库数据的两个状态一个是逻辑上成立的， 事务可以不同程度的一致性：  
##### 隔离性
隔离性指的是两个不同事务之前相互隔离， 互不影响， 隔离级别越严实， 效率就会越低， 隔离级别包括以下  
1. 读未提交， 一个事务还没提交的情况下， 他的更改就可以被其他事务看到
2. 读提交， 一个数据提交以后， 他的修改才能被其他事务看到
3. 可重复读， 一个事务在执行过成中看到的数据总是一样的， 在可重复读隔离级别下， 未提交的事务不会被其他事务看到
4. 串行化， 就是写会加写锁， 读会加读锁， 当读写冲突的时候， 后访问的事务需要等前一个事务执行完成才可以继续执行
##### 持久性
持久性就是事务提交后，对系统的影响是永久的， 持久性是有InnoDB的`redo log`来维护的， 在MySQL中， 每条更新操作都会写一条`redo log`， redo log记录的是物理操作， 记录的是对每个数据页的修改， 所有的更新操作都会先写到redo log中， 然后在将redo log中的数据更新到磁盘中， 因此， 即使数据库异常重启或者宕机， 所有的操作还是记录才redo log中， 当数据库实例启动以后， 可以读取redo log中的数据操作， 将宕机前为写入到数据文件的数据再一次写入， 因此数据不会丢失， 保证了数据的持久性

#### 索引
索引的数据结构模型常用的有
1. 有序数组
2. hash
3. B+树
有序数组是指用一块连续的内存并将数据按一定的顺序存储，有序数组最大的优势在于随机访问的时间复杂度是O(1)， 但是对于插入操作， 有序数组需要挪动插入位置以后的所有数据来完成插入操作  
hash存储是来hash表来组织索引数据， hash表存储数据的优势是等值查询和插入更新的时间复杂度， 缺点就是对于范围查询， 需要遍历全部数据  
B+树，是在查找与插入操作下均衡的实现方式，

大部分情况下， 我们使用的索引都是B+树索引，在MySQL中，每个索引在InnoDb中对应一颗B+树， 根据节点数据的不同， 可以分为普通索引和主键索引  
在主键索引中， 叶子节点中存储的数据是整行数据，在普通索引中， 叶子节点存储的数据是主键id， 所以在InnoDb中， 非主键索引也称为二级索引，为什么要这么做呢， 我想到的结果大概是， 如果在每个索引的叶子节点中都存储整行数据， 那么存储空间的消耗会变得大的多， 使用这种方案应该是兼顾查找性能和存储得折中方案
* 使用了索引和未使用索引在数据查询中有什么区别
我们知道， 索引是有序的， 在进性数据查找时， 如果使用了索引， 那么只需要找到第一个满足条件的数据并往下遍历， 直到不满足条件， 则循环退出， 将结果集返回给客户端， 但如果未使用索引， 则需要进行全表扫描，因为数据时无序的， 所以， 需要从第一行数据开始， 遍历整张表， 取出满足条件的数据作为结果集返回给客户端， 数据量大的情况下， 全表扫描对性能的影响很大， 甚至拖垮整个数据库， 所以， 在使用中， 要尽量使用索引查询， 避免全表扫描

* 普通索引与主键索引在数据查询中的区别  
使用主键索引查找数据时， 因为在主键索引树中叶子节点所存储的数据是整行数据， 所以， 使用护肩索引查找数据时， 找到对应的叶子节点就可以获取到整行数据， 查找次数是一次  
当使用普通索引进行数据搜索时， 对应的过程是这样的，现在对应的耳机索引树上找到对应的叶子节点， 拿到叶子节点中的主键id， 再拿主键id到主键索引树上查找数据， 所以， 使用二级索引进行数据查找时， 需要进行两次所有， 用主键id到主键索引树上查找数据的操作叫做回表  
因为使用主键索引查找数据比用普通索引查找要上一次回表操作， 索引， 在现实中， 应该尽量的使用主键索引进行数据查询  

* 唯一索引与普通索引的区别
唯一索引和普通索引都是二级索引， 不同的是唯一索引在数据库层面进行了数据的唯一性判断， 那么， 唯一索引与普通索引在使用上有什么差别呢  
在查询中， 如果使用的索引是唯一索引， 因为索引本身做了唯一性约束， 所以， 在等值查询的时候， 使用唯一索引查找的时候， 当找到满足条件的行后， 会直接退出， 将结果返回给客户端， 但是普通索引则还需要再往下遍历，直到找到不满足条件的行， 在整张表的数据是唯一的情况下， 普通索引要比唯一索引扫描一行数据， 实际对查找的性能影响不大  
在更新操作中， InnoDb在每个更新的时候会将更新操作先记录在`change buffer`中， 再统一同步到磁盘上， 由于change buffer是在内存中的， 所以更新数据会变得很快，但是， change buffer只能在普通索引上使用， 因为， 在更新唯一索引的时候， 由于需要做唯一性判断， 所以需要读取原表的数据， 这样的话，也就需要将磁盘中的数据读入到内存中， 既然数据已经在内存中了， 就没有必要再使用change buffer 了， 直接更新内存中的数据就行， 所以， 在进行更新操作的时候， 由于普通索引可以使用change buffer， 唯一所以需要读取磁盘中的数据， 有额外的磁盘消耗， 所以， 在更新操作的时候， 普通索引的性能是要由于唯一索引的。  
因为唯一索引在查找中的性能相对普通索引的优势可以忽略不记， 但是在更新操作的性能上却要明显的低于普通索引， 所以， 在实际中， 业务层能够保证数据的唯一性的情况下， 应该尽量使用普通索引
