---
layout: post
author: eature
published: true
categories: MySQL
tags:
- mysql
---

#### MySQL中SQL语句的执行流程

我们知道， MySQL是支持多存储引擎的， MySQL的大体结构可以分为Server层和存储引擎层  

其中Server层包括  
* 连接器
* 查询缓存
* 分析器
* 优化器
* 执行器

存储引擎层负责数据的读写， 架构是插件式的， 支持`InnoDB` `MyISAM` `Memory` ... 等存储 引擎， 其中， 最常用的是`InnoDB`， 从MySQL5.5.5版本开始就默认使用InnoDB存储引擎， 也就是说， 在执行`create table`创建表的时候， 如果不用`engine=myisam`等指定存储引擎的话， 默认就是InnoDB存储引擎

###### 连接器
使用数据库的第一步就是连接数据库， 这个时候处理客户端连接的就是连接器， 负责跟客户端建立连接、获取权限、维持和管理链接。通常的连接数据库命令  
`~ ❯❯❯ mysql -hhost-uuser -Pport -p`  
建立连接的过程是  
1. 客户端与MySQL完成TCP的三次握手建立TCP连接
2. 验证身份， 即验证用户名和密码
3. 读取用户权限  

使用`mysql> show processlist;`就可查询到所有的数据库连接， 如果客户端长时间没有操作， 则MySQL会自动断开链接， 如果还需要操作则需要重连

数据库链接分为长连接和短连接： 长连接是指客户端的操作都使用同一个操作， 反之则是短连接， 建立连接的过程是复杂的， 而且有额外的资源小号， 所以通常情况下都建议使用长连接， 在使用长连接的时候， MySQL的内存占用可能会涨的很快， 那是因为， MySQL在执行过程中使用的临时内存都是管理在连接对象上的， 长时间积累的话可能导致占用内存太大， 有两个解决方案，第一个是定期重连， 第二个是执行大数据量语句的时候使用`mysql_reset_connection`来将连接回复成刚连接成功时的样子 

*管理员的权限修改并不会影响已经建立的链接*  
###### 查询缓存
在开启了查询缓存的情况下， MySQL会将查询的结果缓存在内存中， 存储的结构就是key-value的结构， key是查询的SQL语句， value则是执行SQL的查询结果， 如果下次执行的SQL语句在查询缓存中， 则会直接返回缓存的结果  
如果一张表上有数据更新的话， 这张表的所有的查询缓存将会被清空， 所以对于更新操作频繁的表则不适开启查询缓存， 查询缓存适合用于长时间没有数据更新的表， 另外查询缓存在MySQL8.0已经完全删除
###### 分析器
在没有命中查询缓存后， 就会到分析器， 分析器所在的功能就是对执行的SQL语句做词法分析， 判断需要执行的SQL语句是否符合MySQL语法， 如果所执行的
SQL语句语法有错， 则会在此阶段终止， 并提示最开始出现语法错误的位置，
###### 优化器
经过分析器以后就能确保用户的sql语句是合法的， 优化器的工作就是优化SQL语句的执行流程， 如在表中定义了多个索引的时候该使用那个索引， 在有排序操作的时候该怎么排序， 在连表操作的时候各个表的执行顺序等等，经过优化器以后就相等于是确定了执行方案
###### 执行器
到执行器以后就是开始真正的执行语句， 首先， 开始执行的时候会先判断有没有对应的权限， 如果没有则会直接返回没有权限的错误， 如果有权限就会打开表， 根据表的存储引擎， 调用相应存储引擎的接口获取数据  
例如 `mysql> select * from table where id = 1;`  
如果table表中的id没有索引， 则执行流程是这样的  
1. 调用引擎获取第一个行数据， 判断是不是， 如果是则将这行数据存到结果集中
2. 执行取下一行数据，重复相同的逻辑， 直到最后一行
3. 将所有满足条件的结果集返回给客户端

如果有索引的话则是  
1. 调用引擎获取第一个满足条件的行， 将这行存到结果集中
2. 获取下一个满足条件的行， 并执行相同的逻辑， 直到取出所有满足条件的行
3. 将结果集返回给客户端
